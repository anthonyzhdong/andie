package cosc202.andie;

import java.awt.image.*;
import java.util.Arrays;
import java.awt.Color;

/**
 * <p>
 *
 * <p>
 * ImageOperation to apply a blotch blur filter to an image.
 * </p>
 *
 * <p>
 * The Blotch Blur filter blurs an image by taking the median of the ARGB values of a set of pixels
 * in a local neighborhood around each pixel. The resulting median ARGB value is then assigned
 * to the original pixel, creating a blurred effect.
 * </p>
 *
 * <p>
 * <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
 * </p>
 * 
 * Comments have been generated by chat-gpt
 *
 * @see java.awt.image.BufferedImage
 * @see java.awt.Color
 * @see cosc202.andie.ImageOperation
 * @author Steven Mills
 * @version 1.0
 */
public class BlotchBlur implements ImageOperation, java.io.Serializable {

    /**
     * The size of the filter to apply. A radius of 1 corresponds to a 3x3 filter,
     * a radius of 2 corresponds to a 5x5 filter, and so on.
     */
    private int radius;
    private boolean sN = false;

    /**
     * Constructs a BlotchBlur object with the specified radius.
     *
     * @param radius the radius of the blotch blur filter
     */
    BlotchBlur(int radius) {
        this.radius = radius;   
    }

    /**
     * Constructs a BlotchBlur object with the default radius of 1.
     * By default, a 3x3 filter is applied.
     */
    BlotchBlur() {
        this(1);
    }

    /**
     * Constructs an BlotchBlur object with the specified type and shift negative flag.
     *
     * @param type the type of the emboss filter
     * @param t    the shift negative flag
     */
    BlotchBlur(int radius, boolean t) {
        this.radius = radius;  
        this.sN = t;
    }


    /**
     * Applies the blotch blur filter to the input image.
     *
     * @param input the image to apply the blotch blur filter to
     * @return the resulting blurred image
     */
    public BufferedImage apply(BufferedImage input) {
        if (sN == true) {input = shiftNegative.fixNegative(input);}

        BufferedImage output = new BufferedImage(input.getColorModel(), input.copyData(null), input.isAlphaPremultiplied(), null);
        
        int size = (2*radius+1) * (2*radius+1);

        int[] alpha = new int[size];
        int[] red = new int[size];
        int[] green = new int[size];
        int[] blue = new int[size];
        Color c = new Color(input.getRGB(0, 0), true);
        
        for (int y = 1; y < input.getHeight(); ++y) {
            for (int x = 1; x < input.getWidth(); ++x) {
                
                int kernalIterator = 0;
                for(int kernalY = 0; kernalY < (2*radius+1); kernalY++) {
                    for(int kernalX = 0; kernalX < (2*radius+1); kernalX++) {

                        if(y >= input.getHeight() - (2*radius+1) - 1 && x <= input.getWidth() - (2*radius+1) - 1) {
                            c = new Color(input.getRGB(x+kernalX-1, y-kernalY), true);
                        } 
                        else if(x >= input.getWidth() - (2*radius+1) - 1 && y <= input.getHeight() - (2*radius+1) - 1) {
                            c = new Color(input.getRGB(x-kernalX, y+kernalY-1), true);
                        } 
                        else if(x >= input.getWidth() - (2*radius+1) - 1 && y >= input.getHeight() - (2*radius+1) - 1) {
                            c = new Color(input.getRGB(x-kernalX, y-kernalY), true);
                        }
                        else {
                            c = new Color(input.getRGB(x+kernalX-1, y+kernalY-1), true);
                        }
                       
                
                        int r = c.getRed();
                        int g = c.getGreen();
                        int b = c.getBlue();
                        int a = c.getAlpha();

                        alpha[kernalIterator] = a;
                        red[kernalIterator] = r;
                        green[kernalIterator] = g;
                        blue[kernalIterator] = b;
                        kernalIterator++;
                    }
                }  
                Arrays.sort(alpha);
                Arrays.sort(red);
                Arrays.sort(green);
                Arrays.sort(blue);
                Color newC = new Color((red[radius+1]), (green[radius+1]), (blue[radius+1]), (alpha[radius+1]));
                output.setRGB(x, y, newC.getRGB());
            }
        }
        return output;
    }
    
}
